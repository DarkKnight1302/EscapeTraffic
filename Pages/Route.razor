@page "/route"
@using TrafficEscape.Models;
@using TrafficEscape.Services.Interfaces;
@inject IJSRuntime jsRuntime;
@inject IGooglePlaceService googlePlaceService;

<h3>Route</h3>
<br/>
<h3>Route</h3>
<br />
<div class="form-group mb-3">
    <label for="sourceLocation">Source Location:</label>
    <input type="text" class="form-control" id="sourceLocation" style="max-width: 720px;"
    @bind="sourceLocation" @oninput="OnSourceLocationInput" />
</div>

<br />
<div class="form-group mb-3">
    <label for="destinationLocation">Destination Location:</label>
    <input type="text" class="form-control" id="destinationLocation" style="max-width: 720px;"
    @bind="destinationLocation" @oninput="OnDestinationLocationInput" />
</div>
<br />
<div class="form-row mb-3">
    <div class="col">
        <label for="startTime">Departure Start Time:</label>
        <input type="time" class="form-control" id="startTime" style="max-width: 150px;" @bind="startTime" />
    </div>
    <br />
    <div class="col">
        <label for="endTime">Departure End Time:</label>
        <input type="time" class="form-control" id="endTime" style="max-width: 150px;" @bind="endTime" />
    </div>
    <br />
</div>

<button class="btn btn-primary" @onclick="SaveRoute">Save</button>

@code {
    private string sourceLocation { get; set; }
    private string destinationLocation { get; set; }
    private DateTime startTime { get; set; }
    private DateTime endTime { get; set; }
    private List<string> sourceSuggestions { get; set; } = new List<string>();
    private List<string> destinationSuggestions { get; set; } = new List<string>();
    private System.Threading.Timer sourceTimer;
    private System.Threading.Timer destinationTimer;

    private async void OnSourceLocationInput(ChangeEventArgs e)
    {
        sourceLocation = e.Value.ToString();
        sourceTimer?.Dispose(); // Dispose previous timer if it exists
        sourceTimer = new System.Threading.Timer((state) =>
        {
            IEnumerable<PlacePrediction> placePredictions = googlePlaceService.GetSuggestionsAsync(sourceLocation).Result;

            StateHasChanged(); // Trigger re-render after suggestions are updated
        }, null, 2000, System.Threading.Timeout.Infinite);
    }

    private async void OnDestinationLocationInput(ChangeEventArgs e)
    {
        destinationLocation = e.Value.ToString();
        destinationTimer?.Dispose(); // Dispose previous timer if it exists
        destinationTimer = new System.Threading.Timer((state) =>
        {
            IEnumerable<PlacePrediction> placePredictions = googlePlaceService.GetSuggestionsAsync(destinationLocation).Result;
            StateHasChanged(); // Trigger re-render after suggestions are updated
        }, null, 2000, System.Threading.Timeout.Infinite);
    }

    private void SaveRoute()
    {
        if (string.IsNullOrWhiteSpace(sourceLocation) || string.IsNullOrWhiteSpace(destinationLocation) ||
            startTime == default || endTime == default)
        {
            ShowErrorMessage("All fields are required.");
            return;
        }

        if (endTime < startTime)
        {
            ShowErrorMessage("End time must be greater than start time.");
            return;
        }

        if (endTime - startTime > TimeSpan.FromHours(4))
        {
            ShowErrorMessage("Time difference must be less than or equal to 4 hours.");
            return;
        }
    }

    private async void ShowErrorMessage(string message)
    {
        await jsRuntime.InvokeVoidAsync("alert", message);
    }
}
